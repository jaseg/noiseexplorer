\title{Noise Explorer: X1X}\date{\today}\begin{document}\maketitle\section{ Message A}

\subsection{Message Pattern Analysis}$ $
Message \texttt{A} is the first message in the \texttt{X1X} Noise Handshake Pattern. It is sent from the initiator to the responder. In this detailed analysis, we attempt to give you some insight into the protocol logic underlying this message. The insight given here does not fully extend down to fully illustrate the exact state transformations conducted by the formal model, but it does describe them at least informally in order to help illustrate how Message \texttt{A} affects the protocol.


\subsubsection{Sending Message A}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{A} using the following function:


\begin{lstlisting}

letfun writeMessage_a(me:principal, them:principal, hs:handshakestate, payload:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = (empty, empty, empty) in
	let e = generate_keypair(key_e(me, them, sid)) in
	let ne = key2bit(getpublickey(e)) in
	let ss = mixHash(ss, ne) in
	(* No PSK, so skipping mixKey *)
	let (ss:symmetricstate, ciphertext:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ns, ciphertext) in
	(hs, message_buffer).

\end{lstlisting}

\paragraph{How each token is processed by the initiator:}$ $

\begin{itemize}

\item \texttt{e}: Signals that the initiator is sending a fresh ephemeral key share as part of this message. This token adds the following state transformations to \texttt{writeMessage\_a}:
\begin{itemize}

\item \texttt{mixHash}, which hashes the new key into the session hash.
\end{itemize}


\end{itemize}
If a static public key was communicated as part of this message, it would have been encrypted as \texttt{ciphertext1}. However, since the initiator does not communicate a static public key here, that value is left empty.


Message \texttt{A}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{encryptAndHash}, which performs an authenticated encryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{encryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Receiving Message A}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{A} using the following function:


\begin{lstlisting}

letfun readMessage_a(me:principal, them:principal, hs:handshakestate, message:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = deconcat3(message) in
	let valid1 = true in
	let re = bit2key(ne) in
	let ss = mixHash(ss, key2bit(re)) in
	(* No PSK, so skipping mixKey *)
	let (ss:symmetricstate, plaintext:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext) in
	if ((valid1 && valid2)) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		(hs, plaintext, true)
	).

\end{lstlisting}

\paragraph{How each token is processed by the responder:}$ $

\begin{itemize}

\item \texttt{e}: Signals that the responder is receiving a fresh ephemeral key share as part of this message. This token adds the following state transformations to \texttt{readMessage\_a}:
\begin{itemize}

\item \texttt{mixHash}, which hashes the new key into the session hash.
\end{itemize}


\end{itemize}
If a static public key was communicated as part of this message, it would have been encrypted as \texttt{ciphertext1}. However, since the initiator does not communicate a static public key here, that value is left empty.


Message \texttt{A}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{decryptAndHash}, which performs an authenticated decryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{decryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Queries and Results}$ $
Message \texttt{A} is tested against four authentication queries and five confidentiality queries.
\paragraph{Authentication Grade 1: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1430,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and \emph{message integrity}. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{someone}, or Alice had their static key compromised before the session began, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 2: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_1430,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and is \emph{Key Compromise Impersonation} resistance. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{someone}, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 3: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and \emph{message integrity}. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{Bob specifically}, or Alice had their static key compromised before the session began, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 4: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || event(LeakS(phase0,alice)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and is \emph{Key Compromise Impersonation} resistance. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{Bob specifically}, or Alice had their static key compromised before the session began.


\paragraph{Confidentiality Grade 1: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Bob's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 2: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 3: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{forward secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session, or after the protocol session along with Alice's static public key (at any time.)


\paragraph{Confidentiality Grade 4: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{weak forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session, or after the protocol session along with Alice's static public key (at any time.)


\paragraph{Confidentiality Grade 5: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{strong forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session.


\section{ Message B}

\subsection{Message Pattern Analysis}$ $
Message \texttt{B} is the second message in the \texttt{X1X} Noise Handshake Pattern. It is sent from the responder to the initiator. In this detailed analysis, we attempt to give you some insight into the protocol logic underlying this message. The insight given here does not fully extend down to fully illustrate the exact state transformations conducted by the formal model, but it does describe them at least informally in order to help illustrate how Message \texttt{B} affects the protocol.


\subsubsection{Sending Message B}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{B} using the following function:


\begin{lstlisting}

letfun writeMessage_b(me:principal, them:principal, hs:handshakestate, payload:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = (empty, empty, empty) in
	let e = generate_keypair(key_e(me, them, sid)) in
	let ne = key2bit(getpublickey(e)) in
	let ss = mixHash(ss, ne) in
	(* No PSK, so skipping mixKey *)
	let ss = mixKey(ss, dh(e, re)) in
	let s = generate_keypair(key_s(me)) in
	let (ss:symmetricstate, ns:bitstring) = encryptAndHash(ss, key2bit(getpublickey(s))) in
	let ss = mixKey(ss, dh(s, re)) in
	let (ss:symmetricstate, ciphertext:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ns, ciphertext) in
	(hs, message_buffer).

\end{lstlisting}

\paragraph{How each token is processed by the responder:}$ $

\begin{itemize}

\item \texttt{e}: Signals that the responder is sending a fresh ephemeral key share as part of this message. This token adds the following state transformations to \texttt{writeMessage\_b}:
\begin{itemize}

\item \texttt{mixHash}, which hashes the new key into the session hash.
\end{itemize}


\item \texttt{ee}: Signals that the responder is calculating a Diffie-Hellman shared secret derived from the initiator's ephemeral key and the responder's ephemeral key as part of this message. This token adds the following state transformations to \texttt{writeMessage\_b}:
\begin{itemize}

\item \texttt{mixKey}, which calls the HKDF function using, as input, the existing \texttt{SymmetricState} key, and \texttt{dh(e, re)}, the Diffie-Hellman share calculated from the initiator's ephemeral key and the responder's ephemeral key.
\end{itemize}


\item \texttt{s}: Signals that the responder is sending a static key share as part of this message. This token adds the following state transformations to \texttt{writeMessage\_b}:
\begin{itemize}

\item \texttt{encryptAndHash} is called on the static public key. If any prior Diffie-Hellman shared secret was established between the sender and the recipient, this allows the responder to communicate their long-term identity with some degree of confidentiality.
\end{itemize}


\item \texttt{es}: Signals that the responder is calculating a Diffie-Hellman shared secret derived from the initiator's ephemeral key and the responder's static key as part of this message. This token adds the following state transformations to \texttt{writeMessage\_b}:
\begin{itemize}

\item \texttt{mixKey}, which calls the HKDF function using, as input, the existing \texttt{SymmetricState} key, and \texttt{dh(e, rs)}, the Diffie-Hellman share calculated from the initiator's ephemeral key and the responder's static key.
\end{itemize}


\end{itemize}
Message \texttt{B}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{encryptAndHash}, which performs an authenticated encryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{encryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Receiving Message B}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{B} using the following function:


\begin{lstlisting}

letfun readMessage_b(me:principal, them:principal, hs:handshakestate, message:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = deconcat3(message) in
	let valid1 = true in
	let re = bit2key(ne) in
	let ss = mixHash(ss, key2bit(re)) in
	(* No PSK, so skipping mixKey *)
	let ss = mixKey(ss, dh(e, re)) in
	let (ss:symmetricstate, ne:bitstring, valid1:bool) = decryptAndHash(ss, ns) in
	let rs = bit2key(ne) in
	let ss = mixKey(ss, dh(e, rs)) in
	let (ss:symmetricstate, plaintext:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext) in
	if ((valid1 && valid2) && (rs = getpublickey(generate_keypair(key_s(them))))) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		(hs, plaintext, true)
	).

\end{lstlisting}

\paragraph{How each token is processed by the initiator:}$ $

\begin{itemize}

\item \texttt{e}: Signals that the initiator is receiving a fresh ephemeral key share as part of this message. This token adds the following state transformations to \texttt{readMessage\_b}:
\begin{itemize}

\item \texttt{mixHash}, which hashes the new key into the session hash.
\end{itemize}


\item \texttt{ee}: Signals that the initiator is calculating a Diffie-Hellman shared secret derived from the initiator's ephemeral key and the responder's ephemeral key as part of this message. This token adds the following state transformations to \texttt{readMessage\_b}:
\begin{itemize}

\item \texttt{mixKey}, which calls the HKDF function using, as input, the existing \texttt{SymmetricState} key, and \texttt{dh(e, re)}, the Diffie-Hellman share calculated from the initiator's ephemeral key and the responder's ephemeral key.
\end{itemize}


\item \texttt{s}: Signals that the initiator is receiving a static key share as part of this message. This token adds the following state transformations to \texttt{readMessage\_b}:
\begin{itemize}

\item \texttt{encryptAndHash} is called on the static public key. If any prior Diffie-Hellman shared secret was established between the sender and the recipient, this allows the responder to communicate their long-term identity with some degree of confidentiality.
\end{itemize}


\item \texttt{es}: Signals that the initiator is calculating a Diffie-Hellman shared secret derived from the initiator's ephemeral key and the responder's static key as part of this message. This token adds the following state transformations to \texttt{readMessage\_b}:
\begin{itemize}

\item \texttt{mixKey}, which calls the HKDF function using, as input, the existing \texttt{SymmetricState} key, and \texttt{dh(e, rs)}, the Diffie-Hellman share calculated from the initiator's ephemeral key and the responder's static key.
\end{itemize}


\end{itemize}
Message \texttt{B}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{decryptAndHash}, which performs an authenticated decryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{decryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Queries and Results}$ $
Message \texttt{B} is tested against four authentication queries and five confidentiality queries.
\paragraph{Authentication Grade 1: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1430,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and \emph{message integrity}. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{someone}, or Bob had their static key compromised before the session began, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 2: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,c_1430,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and is \emph{Key Compromise Impersonation} resistance. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{someone}, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 3: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and \emph{message integrity}. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{Alice specifically}, or Bob had their static key compromised before the session began, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 4: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m)) || event(LeakS(phase0,bob)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and is \emph{Key Compromise Impersonation} resistance. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{Alice specifically}, or Bob had their static key compromised before the session began.


\paragraph{Confidentiality Grade 1: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Alice's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 2: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 3: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) is true.
\end{lstlisting}

In this query, we test for \emph{forward secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session, or after the protocol session along with Bob's static public key (at any time.)


\paragraph{Confidentiality Grade 4: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{weak forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session, or after the protocol session along with Bob's static public key (at any time.)


\paragraph{Confidentiality Grade 5: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{strong forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session.


\section{ Message C}

\subsection{Message Pattern Analysis}$ $
Message \texttt{C} is the third message in the \texttt{X1X} Noise Handshake Pattern. It is sent from the initiator to the responder. In this detailed analysis, we attempt to give you some insight into the protocol logic underlying this message. The insight given here does not fully extend down to fully illustrate the exact state transformations conducted by the formal model, but it does describe them at least informally in order to help illustrate how Message \texttt{C} affects the protocol.


\subsubsection{Sending Message C}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{C} using the following function:


\begin{lstlisting}

letfun writeMessage_c(me:principal, them:principal, hs:handshakestate, payload:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = (empty, empty, empty) in
	let s = generate_keypair(key_s(me)) in
	let (ss:symmetricstate, ns:bitstring) = encryptAndHash(ss, key2bit(getpublickey(s))) in
	let (ss:symmetricstate, ciphertext:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ns, ciphertext) in
	(hs, message_buffer).

\end{lstlisting}

\paragraph{How each token is processed by the initiator:}$ $

\begin{itemize}

\item \texttt{s}: Signals that the initiator is sending a static key share as part of this message. This token adds the following state transformations to \texttt{writeMessage\_c}:
\begin{itemize}

\item \texttt{encryptAndHash} is called on the static public key. If any prior Diffie-Hellman shared secret was established between the sender and the recipient, this allows the initiator to communicate their long-term identity with some degree of confidentiality.
\end{itemize}


\end{itemize}
Message \texttt{C}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{encryptAndHash}, which performs an authenticated encryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{encryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Receiving Message C}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{C} using the following function:


\begin{lstlisting}

letfun readMessage_c(me:principal, them:principal, hs:handshakestate, message:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = deconcat3(message) in
	let valid1 = true in
	let (ss:symmetricstate, ne:bitstring, valid1:bool) = decryptAndHash(ss, ns) in
	let rs = bit2key(ne) in
	let (ss:symmetricstate, plaintext:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext) in
	if ((valid1 && valid2) && (rs = getpublickey(generate_keypair(key_s(them))))) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		(hs, plaintext, true)
	).

\end{lstlisting}

\paragraph{How each token is processed by the responder:}$ $

\begin{itemize}

\item \texttt{s}: Signals that the responder is receiving a static key share as part of this message. This token adds the following state transformations to \texttt{readMessage\_c}:
\begin{itemize}

\item \texttt{encryptAndHash} is called on the static public key. If any prior Diffie-Hellman shared secret was established between the sender and the recipient, this allows the initiator to communicate their long-term identity with some degree of confidentiality.
\end{itemize}


\end{itemize}
Message \texttt{C}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{decryptAndHash}, which performs an authenticated decryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{decryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Queries and Results}$ $
Message \texttt{C} is tested against four authentication queries and five confidentiality queries.
\paragraph{Authentication Grade 1: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1430,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and \emph{message integrity}. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{someone}, or Alice had their static key compromised before the session began, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 2: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,c_1430,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and is \emph{Key Compromise Impersonation} resistance. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{someone}, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 3: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and \emph{message integrity}. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{Bob specifically}, or Alice had their static key compromised before the session began, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 4: Failed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m)) || event(LeakS(phase0,alice)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and is \emph{Key Compromise Impersonation} resistance. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{Bob specifically}, or Alice had their static key compromised before the session began.


\paragraph{Confidentiality Grade 1: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Bob's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 2: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 3: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) is true.
\end{lstlisting}

In this query, we test for \emph{forward secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session, or after the protocol session along with Alice's static public key (at any time.)


\paragraph{Confidentiality Grade 4: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) is true.
\end{lstlisting}

In this query, we test for \emph{weak forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session, or after the protocol session along with Alice's static public key (at any time.)


\paragraph{Confidentiality Grade 5: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{strong forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session.


\section{ Message D}

\subsection{Message Pattern Analysis}$ $
Message \texttt{D} is the fourth message in the \texttt{X1X} Noise Handshake Pattern. It is sent from the responder to the initiator. In this detailed analysis, we attempt to give you some insight into the protocol logic underlying this message. The insight given here does not fully extend down to fully illustrate the exact state transformations conducted by the formal model, but it does describe them at least informally in order to help illustrate how Message \texttt{D} affects the protocol.


\subsubsection{Sending Message D}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{D} using the following function:


\begin{lstlisting}

letfun writeMessage_d(me:principal, them:principal, hs:handshakestate, payload:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = (empty, empty, empty) in
	let ss = mixKey(ss, dh(e, rs)) in
	let (ss:symmetricstate, ciphertext:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ns, ciphertext) in
	let (ssi:symmetricstate, cs1:cipherstate, cs2:cipherstate) = split(ss) in
	(hs, message_buffer, cs1, cs2).

\end{lstlisting}

\paragraph{How each token is processed by the responder:}$ $

\begin{itemize}

\item \texttt{se}: Signals that the responder is calculating a Diffie-Hellman shared secret derived from the initiator's static key and the responder's ephemeral key as part of this message. This token adds the following state transformations to \texttt{writeMessage\_d}:
\begin{itemize}

\item \texttt{mixKey}, which calls the HKDF function using, as input, the existing \texttt{SymmetricState} key, and \texttt{dh(s, re)}, the Diffie-Hellman share calculated from the initiator's static key and the responder's ephemeral key.
\end{itemize}


\end{itemize}
If a static public key was communicated as part of this message, it would have been encrypted as \texttt{ciphertext1}. However, since the initiator does not communicate a static public key here, that value is left empty.


Message \texttt{D}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{encryptAndHash}, which performs an authenticated encryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{encryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Receiving Message D}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{D} using the following function:


\begin{lstlisting}

letfun readMessage_d(me:principal, them:principal, hs:handshakestate, message:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = deconcat3(message) in
	let valid1 = true in
	let ss = mixKey(ss, dh(s, re)) in
	let (ss:symmetricstate, plaintext:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext) in
	if ((valid1 && valid2)) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		let (ssi:symmetricstate, cs1:cipherstate, cs2:cipherstate) = split(ss) in
		(hs, plaintext, true, cs1, cs2)
	).

\end{lstlisting}

\paragraph{How each token is processed by the initiator:}$ $

\begin{itemize}

\item \texttt{se}: Signals that the initiator is calculating a Diffie-Hellman shared secret derived from the initiator's static key and the responder's ephemeral key as part of this message. This token adds the following state transformations to \texttt{readMessage\_d}:
\begin{itemize}

\item \texttt{mixKey}, which calls the HKDF function using, as input, the existing \texttt{SymmetricState} key, and \texttt{dh(s, re)}, the Diffie-Hellman share calculated from the initiator's static key and the responder's ephemeral key.
\end{itemize}


\end{itemize}
If a static public key was communicated as part of this message, it would have been encrypted as \texttt{ciphertext1}. However, since the initiator does not communicate a static public key here, that value is left empty.


Message \texttt{D}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{decryptAndHash}, which performs an authenticated decryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{decryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Queries and Results}$ $
Message \texttt{D} is tested against four authentication queries and five confidentiality queries.
\paragraph{Authentication Grade 1: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1430,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and \emph{message integrity}. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{someone}, or Bob had their static key compromised before the session began, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 2: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,c_1430,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and is \emph{Key Compromise Impersonation} resistance. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{someone}, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 3: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and \emph{message integrity}. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{Alice specifically}, or Bob had their static key compromised before the session began, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 4: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m)) || event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and is \emph{Key Compromise Impersonation} resistance. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{Alice specifically}, or Bob had their static key compromised before the session began.


\paragraph{Confidentiality Grade 1: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Alice's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 2: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 3: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) is true.
\end{lstlisting}

In this query, we test for \emph{forward secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session, or after the protocol session along with Bob's static public key (at any time.)


\paragraph{Confidentiality Grade 4: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{weak forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session, or after the protocol session along with Bob's static public key (at any time.)


\paragraph{Confidentiality Grade 5: Failed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) cannot be proved.
\end{lstlisting}

In this query, we test for \emph{strong forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session.


\section{ Message E}

\subsection{Message Pattern Analysis}$ $
Message \texttt{E} is the fifth message in the \texttt{X1X} Noise Handshake Pattern. It is sent from the initiator to the responder. In this detailed analysis, we attempt to give you some insight into the protocol logic underlying this message. The insight given here does not fully extend down to fully illustrate the exact state transformations conducted by the formal model, but it does describe them at least informally in order to help illustrate how Message \texttt{E} affects the protocol.


\subsubsection{Sending Message E}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{E} using the following function:


\begin{lstlisting}

letfun writeMessage_e(me:principal, them:principal, hs:handshakestate, payload:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = (empty, empty, empty) in
	let (ss:symmetricstate, ciphertext:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ns, ciphertext) in
	(hs, message_buffer).

\end{lstlisting}

Since Message \texttt{E} contains no tokens, it is considered purely an "AppData" type message meant to transfer encrypted payloads.
If a static public key was communicated as part of this message, it would have been encrypted as \texttt{ciphertext1}. However, since the initiator does not communicate a static public key here, that value is left empty.


Message \texttt{E}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{encryptAndHash}, which performs an authenticated encryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{encryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Receiving Message E}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{E} using the following function:


\begin{lstlisting}

letfun readMessage_e(me:principal, them:principal, hs:handshakestate, message:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = deconcat3(message) in
	let valid1 = true in
	let (ss:symmetricstate, plaintext:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext) in
	if ((valid1 && valid2)) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		(hs, plaintext, true)
	).

\end{lstlisting}

Since Message \texttt{E} contains no tokens, it is considered purely an "AppData" type message meant to transfer encrypted payloads.
If a static public key was communicated as part of this message, it would have been encrypted as \texttt{ciphertext1}. However, since the initiator does not communicate a static public key here, that value is left empty.


Message \texttt{E}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{decryptAndHash}, which performs an authenticated decryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{decryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Queries and Results}$ $
Message \texttt{E} is tested against four authentication queries and five confidentiality queries.
\paragraph{Authentication Grade 1: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,c_1430,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and \emph{message integrity}. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{someone}, or Alice had their static key compromised before the session began, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 2: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,c_1430,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and is \emph{Key Compromise Impersonation} resistance. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{someone}, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 3: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)) || event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and \emph{message integrity}. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{Bob specifically}, or Alice had their static key compromised before the session began, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 4: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m)) || event(LeakS(phase0,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and is \emph{Key Compromise Impersonation} resistance. If Bob receives a valid message from Alice, then Alice must have sent that message to \emph{Bob specifically}, or Alice had their static key compromised before the session began.


\paragraph{Confidentiality Grade 1: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Bob's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 2: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || event(LeakS(phase1,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 3: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) is true.
\end{lstlisting}

In this query, we test for \emph{forward secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session, or after the protocol session along with Alice's static public key (at any time.)


\paragraph{Confidentiality Grade 4: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(phase1,bob)) && event(LeakS(p,alice))) is true.
\end{lstlisting}

In this query, we test for \emph{weak forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session, or after the protocol session along with Alice's static public key (at any time.)


\paragraph{Confidentiality Grade 5: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{strong forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Bob's static key before the protocol session.


\section{ Message F}

\subsection{Message Pattern Analysis}$ $
Message \texttt{F} is the sixth message in the \texttt{X1X} Noise Handshake Pattern. It is sent from the responder to the initiator. In this detailed analysis, we attempt to give you some insight into the protocol logic underlying this message. The insight given here does not fully extend down to fully illustrate the exact state transformations conducted by the formal model, but it does describe them at least informally in order to help illustrate how Message \texttt{F} affects the protocol.


\subsubsection{Sending Message F}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{F} using the following function:


\begin{lstlisting}

letfun writeMessage_f(me:principal, them:principal, hs:handshakestate, payload:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = (empty, empty, empty) in
	let (ss:symmetricstate, ciphertext:bitstring) = encryptAndHash(ss, payload) in
	let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
	let message_buffer = concat3(ne, ns, ciphertext) in
	(hs, message_buffer).

\end{lstlisting}

Since Message \texttt{F} contains no tokens, it is considered purely an "AppData" type message meant to transfer encrypted payloads.
If a static public key was communicated as part of this message, it would have been encrypted as \texttt{ciphertext1}. However, since the initiator does not communicate a static public key here, that value is left empty.


Message \texttt{F}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{encryptAndHash}, which performs an authenticated encryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{encryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Receiving Message F}$ $
In the applied pi calculus, the initiator's process prepares Message \texttt{F} using the following function:


\begin{lstlisting}

letfun readMessage_f(me:principal, them:principal, hs:handshakestate, message:bitstring, sid:sessionid) =
	let (ss:symmetricstate, s:keypair, e:keypair, rs:key, re:key, psk:key, initiator:bool) = handshakestateunpack(hs) in
	let (ne:bitstring, ns:bitstring, ciphertext:bitstring) = deconcat3(message) in
	let valid1 = true in
	let (ss:symmetricstate, plaintext:bitstring, valid2:bool) = decryptAndHash(ss, ciphertext) in
	if ((valid1 && valid2)) then (
		let hs = handshakestatepack(ss, s, e, rs, re, psk, initiator) in
		(hs, plaintext, true)
	).

\end{lstlisting}

Since Message \texttt{F} contains no tokens, it is considered purely an "AppData" type message meant to transfer encrypted payloads.
If a static public key was communicated as part of this message, it would have been encrypted as \texttt{ciphertext1}. However, since the initiator does not communicate a static public key here, that value is left empty.


Message \texttt{F}'s payload, which is modeled as the output of the function \texttt{msg\_a(initiatorIdentity, responderIdentity, sessionId)}, is encrypted as \texttt{ciphertext2}. This invokes the following operations:


\begin{itemize}

\item \texttt{decryptAndHash}, which performs an authenticated decryption with added data (AEAD) on the payload, with the session hash as the added data (\texttt{decryptWithAd}) and \texttt{mixHash}, which hashes the encrypted payload into the next session hash.

\end{itemize}
\subsubsection{Queries and Results}$ $
Message \texttt{F} is tested against four authentication queries and five confidentiality queries.
\paragraph{Authentication Grade 1: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,c_1430,stagepack_f(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and \emph{message integrity}. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{someone}, or Bob had their static key compromised before the session began, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 2: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,c_1430,stagepack_f(sid_b),m)) || event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{sender authentication} and is \emph{Key Compromise Impersonation} resistance. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{someone}, or Bob had their static key compromised before the session began.


\paragraph{Authentication Grade 3: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_f(sid_b),m)) || event(LeakS(phase0,bob)) || event(LeakS(phase0,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and \emph{message integrity}. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{Alice specifically}, or Bob had their static key compromised before the session began, or Alice had their static key compromised before the session began.


\paragraph{Authentication Grade 4: Passed}$ $
\begin{lstlisting}
RESULT event(RecvMsg(alice,bob,stagepack_f(sid_a),m)) ==> event(SendMsg(bob,alice,stagepack_f(sid_b),m)) || event(LeakS(phase0,bob)) is true.
\end{lstlisting}

In this query, we test for \emph{sender and receiver authentication} and is \emph{Key Compromise Impersonation} resistance. If Alice receives a valid message from Bob, then Bob must have sent that message to \emph{Alice specifically}, or Bob had their static key compromised before the session began.


\paragraph{Confidentiality Grade 1: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_f(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Alice's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 2: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_f(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || event(LeakS(phase1,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{message secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key either before or after the protocol session.


\paragraph{Confidentiality Grade 3: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_f(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) is true.
\end{lstlisting}

In this query, we test for \emph{forward secrecy} by checking if a passive attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session, or after the protocol session along with Bob's static public key (at any time.)


\paragraph{Confidentiality Grade 4: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_f(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) || (event(LeakS(phase1,alice)) && event(LeakS(p,bob))) is true.
\end{lstlisting}

In this query, we test for \emph{weak forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session, or after the protocol session along with Bob's static public key (at any time.)


\paragraph{Confidentiality Grade 5: Passed}$ $
\begin{lstlisting}
RESULT attacker_p1(msg_f(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) is true.
\end{lstlisting}

In this query, we test for \emph{strong forward secrecy} by checking if an active attacker is able to retrieve the payload plaintext only by compromising Alice's static key before the protocol session.


